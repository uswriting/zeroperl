diff --git a/pp_sys.c b/pp_sys.c
index 5f8bb0d6ed..ac7455211c 100644
--- a/pp_sys.c
+++ b/pp_sys.c
@@ -650,8 +650,8 @@ PP_wrapped(pp_die, 0, 1)
  * look like this on entry:
  *     -  X  A0 A1 A2 ...
  *     |
- *  mark 
- * 
+ *  mark
+ *
  * where X is an SV to be thrown away (it's typically the original
  * filehandle), then the method is called (on a new stack) with args:
  *   (tied_obj(sv), A0, A1, ...)
@@ -3022,7 +3022,7 @@ PP_wrapped(pp_getpeername, 1, 0)
             if (((struct sockaddr *)SvPVX_const(sv))->sa_family == AF_INET &&
                 !memcmp(SvPVX_const(sv) + sizeof(u_short), nowhere,
                         sizeof(u_short) + sizeof(struct in_addr))) {
-                goto nuts2;	
+                goto nuts2;
             }
         }
 #endif
@@ -3059,74 +3059,111 @@ PP_wrapped(pp_stat, !(PL_op->op_flags & OPf_REF), 0)
     IO *io = NULL;
     U8 gimme;
     I32 max = 13;
-    SV* sv;
+    SV *sv;
+
+    PerlIO_printf(Perl_debug_log, "Entering pp_stat with op_flags: %d\n", PL_op->op_flags);
 
     if (PL_op->op_flags & OPf_REF ? (gv = cGVOP_gv, 1)
-                                  : cBOOL((sv=POPs, gv = MAYBE_DEREF_GV(sv))))
+                                  : cBOOL((sv = POPs, gv = MAYBE_DEREF_GV(sv))))
     {
-        if (PL_op->op_type == OP_LSTAT) {
-            if (gv != PL_defgv) {
+        PerlIO_printf(Perl_debug_log, "Entered GV branch (filehandle)\n");
+        if (PL_op->op_type == OP_LSTAT)
+        {
+            PerlIO_printf(Perl_debug_log, "OP_LSTAT check: gv=%p, defgv=%p\n", (void *)gv, (void *)PL_defgv);
+            if (gv != PL_defgv)
+            {
             do_fstat_warning_check:
+                PerlIO_printf(Perl_debug_log, "Issuing fstat warning for filehandle\n");
                 Perl_ck_warner(aTHX_ packWARN(WARN_IO),
                                "lstat() on filehandle%s%" SVf,
-                                gv ? " " : "",
-                                SVfARG(gv
-                                        ? newSVhek_mortal(GvENAME_HEK(gv))
-                                        : &PL_sv_no));
-            } else if (PL_laststype != OP_LSTAT)
+                               gv ? " " : "",
+                               SVfARG(gv
+                                          ? newSVhek_mortal(GvENAME_HEK(gv))
+                                          : &PL_sv_no));
+            }
+            else if (PL_laststype != OP_LSTAT)
                 /* diag_listed_as: The stat preceding %s wasn't an lstat */
                 Perl_croak(aTHX_ "The stat preceding lstat() wasn't an lstat");
         }
 
-        if (gv == PL_defgv) {
+        if (gv == PL_defgv)
+        {
+            PerlIO_printf(Perl_debug_log, "Using default GV, laststatval=%d\n", PL_laststatval);
             if (PL_laststatval < 0)
-                SETERRNO(EBADF,RMS_IFI);
-        } else {
-          do_fstat_have_io:
+                SETERRNO(EBADF, RMS_IFI);
+        }
+        else
+        {
+        do_fstat_have_io:
+            PerlIO_printf(Perl_debug_log, "Performing fstat on IO handle\n");
             PL_laststype = OP_STAT;
             PL_statgv = gv ? gv : (GV *)io;
             SvPVCLEAR(PL_statname);
-            if(gv) {
+            if (gv)
+            {
                 io = GvIO(gv);
             }
-            if (io) {
-                    if (IoIFP(io)) {
-                        int fd = PerlIO_fileno(IoIFP(io));
-                        if (fd < 0) {
-                            report_evil_fh(gv);
-                            PL_laststatval = -1;
-                            SETERRNO(EBADF,RMS_IFI);
-                        } else {
-                            PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
-                        }
-                    } else if (IoDIRP(io)) {
-                        PL_laststatval =
-                            PerlLIO_fstat(my_dirfd(IoDIRP(io)), &PL_statcache);
-                    } else {
+            if (io)
+            {
+                if (IoIFP(io))
+                {
+                    int fd = PerlIO_fileno(IoIFP(io));
+                    PerlIO_printf(Perl_debug_log, "Got file descriptor: %d\n", fd);
+                    if (fd < 0)
+                    {
+                        PerlIO_printf(Perl_debug_log, "ERROR: Invalid file descriptor\n");
                         report_evil_fh(gv);
                         PL_laststatval = -1;
-                        SETERRNO(EBADF,RMS_IFI);
+                        SETERRNO(EBADF, RMS_IFI);
+                    }
+                    else
+                    {
+                        PL_laststatval = PerlLIO_fstat(fd, &PL_statcache);
+                        PerlIO_printf(Perl_debug_log, "fstat result: %d\n", PL_laststatval);
                     }
-            } else {
+                }
+                else if (IoDIRP(io))
+                {
+                    PerlIO_printf(Perl_debug_log, "Performing fstat on directory handle\n");
+                    PL_laststatval =
+                        PerlLIO_fstat(my_dirfd(IoDIRP(io)), &PL_statcache);
+                }
+                else
+                {
+                    PerlIO_printf(Perl_debug_log, "ERROR: Invalid IO handle type\n");
+                    report_evil_fh(gv);
+                    PL_laststatval = -1;
+                    SETERRNO(EBADF, RMS_IFI);
+                }
+            }
+            else
+            {
+                PerlIO_printf(Perl_debug_log, "ERROR: No IO handle available\n");
                 report_evil_fh(gv);
                 PL_laststatval = -1;
-                SETERRNO(EBADF,RMS_IFI);
+                SETERRNO(EBADF, RMS_IFI);
             }
         }
 
-        if (PL_laststatval < 0) {
+        if (PL_laststatval < 0)
+        {
+            PerlIO_printf(Perl_debug_log, "Stat failed, setting max=0\n");
             max = 0;
         }
     }
-    else {
+    else
+    {
         const char *file;
         const char *temp;
         STRLEN len;
-        if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO) { 
+        PerlIO_printf(Perl_debug_log, "Entered filename branch\n");
+        if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVIO)
+        {
+            PerlIO_printf(Perl_debug_log, "Got reference to IO\n");
             io = MUTABLE_IO(SvRV(sv));
             if (PL_op->op_type == OP_LSTAT)
                 goto do_fstat_warning_check;
-            goto do_fstat_have_io; 
+            goto do_fstat_have_io;
         }
         SvTAINTED_off(PL_statname); /* previous tainting irrelevant */
         temp = SvPV_nomg_const(sv, len);
@@ -3134,17 +3171,23 @@ PP_wrapped(pp_stat, !(PL_op->op_flags & OPf_REF), 0)
         PL_statgv = NULL;
         PL_laststype = PL_op->op_type;
         file = SvPV_nolen_const(PL_statname);
-        if (!IS_SAFE_PATHNAME(temp, len, OP_NAME(PL_op))) {
+        PerlIO_printf(Perl_debug_log, "Attempting stat on file: %s\n", file);
+        if (!IS_SAFE_PATHNAME(temp, len, OP_NAME(PL_op)))
+        {
+            PerlIO_printf(Perl_debug_log, "ERROR: Unsafe pathname\n");
             PL_laststatval = -1;
         }
         else if (PL_op->op_type == OP_LSTAT)
             PL_laststatval = PerlLIO_lstat(file, &PL_statcache);
         else
             PL_laststatval = PerlLIO_stat(file, &PL_statcache);
-        if (PL_laststatval < 0) {
-            if (ckWARN(WARN_NEWLINE) && should_warn_nl(file)) {
+        if (PL_laststatval < 0)
+        {
+            PerlIO_printf(Perl_debug_log, "Stat failed with errno: %d\n", errno);
+            if (ckWARN(WARN_NEWLINE) && should_warn_nl(file))
+            {
                 /* PL_warn_nl is constant */
-                GCC_DIAG_IGNORE_STMT(-Wformat-nonliteral);
+                GCC_DIAG_IGNORE_STMT(-Wformat - nonliteral);
                 Perl_warner(aTHX_ packWARN(WARN_NEWLINE), PL_warn_nl, "stat");
                 GCC_DIAG_RESTORE_STMT;
             }
@@ -3153,44 +3196,58 @@ PP_wrapped(pp_stat, !(PL_op->op_flags & OPf_REF), 0)
     }
 
     gimme = GIMME_V;
-    if (gimme != G_LIST) {
+    PerlIO_printf(Perl_debug_log, "GIMME context: %d\n", gimme);
+    if (gimme != G_LIST)
+    {
         if (gimme != G_VOID)
             XPUSHs(boolSV(max));
+        PerlIO_printf(Perl_debug_log, "Returning early - not LIST context\n");
         RETURN;
     }
-    if (max) {
+    if (max)
+    {
+        PerlIO_printf(Perl_debug_log, "Processing stat results for LIST context\n");
         EXTEND(SP, max);
         EXTEND_MORTAL(max);
 #if ST_DEV_SIZE < IVSIZE || (ST_DEV_SIZE == IVSIZE && ST_DEV_SIGN < 0)
+        PerlIO_printf(Perl_debug_log, "ST_DEV_SIZE < IVSIZE branch\n");
         mPUSHi(PL_statcache.st_dev);
 #elif ST_DEV_SIZE == IVSIZE
+        PerlIO_printf(Perl_debug_log, "ST_DEV_SIZE == IVSIZE branch\n");
         mPUSHu(PL_statcache.st_dev);
 #else
-#  if ST_DEV_SIGN < 0
-        if (LIKELY((IV)PL_statcache.st_dev == PL_statcache.st_dev)) {
+#if ST_DEV_SIGN < 0
+        PerlIO_printf(Perl_debug_log, "ST_DEV_SIGN < 0 branch\n");
+        if (LIKELY((IV)PL_statcache.st_dev == PL_statcache.st_dev))
+        {
             mPUSHi((IV)PL_statcache.st_dev);
         }
-#  else
-        if (LIKELY((UV)PL_statcache.st_dev == PL_statcache.st_dev)) {
+#else
+        PerlIO_printf(Perl_debug_log, "ST_DEV_SIGN >= 0 branch\n");
+        if (LIKELY((UV)PL_statcache.st_dev == PL_statcache.st_dev))
+        {
             mPUSHu((UV)PL_statcache.st_dev);
         }
-#  endif
-        else {
-            char buf[sizeof(PL_statcache.st_dev)*3+1];
+#endif
+        else
+        {
+            char buf[sizeof(PL_statcache.st_dev) * 3 + 1];
             /* sv_catpvf() casts 'j' size values down to IV, so it
                isn't suitable for use here.
             */
-#    if defined(I_INTTYPES) && defined(HAS_SNPRINTF)
-#      if ST_DEV_SIGN < 0
+#if defined(I_INTTYPES) && defined(HAS_SNPRINTF)
+#if ST_DEV_SIGN < 0
+            PerlIO_printf(Perl_debug_log, "Using snprintf for large negative st_dev\n");
             int size = snprintf(buf, sizeof(buf), "%" PRIdMAX, (intmax_t)PL_statcache.st_dev);
-#      else
+#else
+            PerlIO_printf(Perl_debug_log, "Using snprintf for large positive st_dev\n");
             int size = snprintf(buf, sizeof(buf), "%" PRIuMAX, (uintmax_t)PL_statcache.st_dev);
-#      endif
+#endif
             STATIC_ASSERT_STMT(sizeof(intmax_t) >= sizeof(PL_statcache.st_dev));
             mPUSHp(buf, size);
-#    else
-#      error extraordinarily large st_dev but no inttypes.h or no snprintf
-#    endif
+#else
+#error extraordinarily large st_dev but no inttypes.h or no snprintf
+#endif
         }
 #endif
         {
@@ -3208,87 +3265,127 @@ PP_wrapped(pp_stat, !(PL_op->op_flags & OPf_REF), 0)
              */
             bool neg;
             Stat_t s;
-            CLANG_DIAG_IGNORE_STMT(-Wtautological-compare);
-            GCC_DIAG_IGNORE_STMT(-Wtype-limits);
+            CLANG_DIAG_IGNORE_STMT(-Wtautological - compare);
+            GCC_DIAG_IGNORE_STMT(-Wtype - limits);
 #if defined(__HP_cc) || defined(__HP_aCC)
 #pragma diag_suppress 2186
 #endif
             neg = PL_statcache.st_ino < 0;
+            PerlIO_printf(Perl_debug_log, "st_ino negative: %d\n", neg);
 #if defined(__HP_cc) || defined(__HP_aCC)
 #pragma diag_default 2186
 #endif
             GCC_DIAG_RESTORE_STMT;
             CLANG_DIAG_RESTORE_STMT;
-            if (neg) {
+            if (neg)
+            {
+                PerlIO_printf(Perl_debug_log, "Handling negative st_ino\n");
                 s.st_ino = (IV)PL_statcache.st_ino;
-                if (LIKELY(s.st_ino == PL_statcache.st_ino)) {
+                if (LIKELY(s.st_ino == PL_statcache.st_ino))
+                {
+                    PerlIO_printf(Perl_debug_log, "Using direct IV for st_ino\n");
                     mPUSHi(s.st_ino);
-                } else {
-                    char buf[sizeof(s.st_ino)*3+1], *p;
+                }
+                else
+                {
+                    PerlIO_printf(Perl_debug_log, "Converting large negative st_ino to string\n");
+                    char buf[sizeof(s.st_ino) * 3 + 1], *p;
                     s.st_ino = PL_statcache.st_ino;
-                    for (p = buf + sizeof(buf); p != buf+1; ) {
+                    for (p = buf + sizeof(buf); p != buf + 1;)
+                    {
                         Stat_t t;
                         t.st_ino = s.st_ino / 10;
-                        *--p = '0' + (int)(t.st_ino*10 - s.st_ino);
+                        *--p = '0' + (int)(t.st_ino * 10 - s.st_ino);
                         s.st_ino = t.st_ino;
                     }
                     while (*p == '0')
                         p++;
                     *--p = '-';
-                    mPUSHp(p, buf+sizeof(buf) - p);
+                    mPUSHp(p, buf + sizeof(buf) - p);
                 }
-            } else {
+            }
+            else
+            {
+                PerlIO_printf(Perl_debug_log, "Handling non-negative st_ino\n");
                 s.st_ino = (UV)PL_statcache.st_ino;
-                if (LIKELY(s.st_ino == PL_statcache.st_ino)) {
+                if (LIKELY(s.st_ino == PL_statcache.st_ino))
+                {
+                    PerlIO_printf(Perl_debug_log, "Using direct UV for st_ino\n");
                     mPUSHu(s.st_ino);
-                } else {
-                    char buf[sizeof(s.st_ino)*3], *p;
+                }
+                else
+                {
+                    PerlIO_printf(Perl_debug_log, "Converting large positive st_ino to string\n");
+                    char buf[sizeof(s.st_ino) * 3], *p;
                     s.st_ino = PL_statcache.st_ino;
-                    for (p = buf + sizeof(buf); p != buf; ) {
+                    for (p = buf + sizeof(buf); p != buf;)
+                    {
                         Stat_t t;
                         t.st_ino = s.st_ino / 10;
-                        *--p = '0' + (int)(s.st_ino - t.st_ino*10);
+                        *--p = '0' + (int)(s.st_ino - t.st_ino * 10);
                         s.st_ino = t.st_ino;
                     }
                     while (*p == '0')
                         p++;
-                    mPUSHp(p, buf+sizeof(buf) - p);
+                    mPUSHp(p, buf + sizeof(buf) - p);
                 }
             }
         }
         mPUSHu(PL_statcache.st_mode);
         mPUSHu(PL_statcache.st_nlink);
-        
+
         sv_setuid(PUSHmortal, PL_statcache.st_uid);
         sv_setgid(PUSHmortal, PL_statcache.st_gid);
 
 #ifdef USE_STAT_RDEV
+        PerlIO_printf(Perl_debug_log, "Using st_rdev\n");
         mPUSHi(PL_statcache.st_rdev);
 #else
+        PerlIO_printf(Perl_debug_log, "No st_rdev available\n");
         PUSHs(newSVpvs_flags("", SVs_TEMP));
 #endif
+
+#ifdef __wasi__
+        /* Force floating point for WASI large files */
+        PerlIO_printf(Perl_debug_log, "WASI: Using floating point for st_size\n");
+        PerlIO_printf(Perl_debug_log, "st_size value: %lld\n", (long long)PL_statcache.st_size);
+        mPUSHn(PL_statcache.st_size);
+#else
+        /* Original size handling logic */
 #if Off_t_size > IVSIZE
+        PerlIO_printf(Perl_debug_log, "Using floating point for st_size (Off_t_size > IVSIZE)\n");
+        PerlIO_printf(Perl_debug_log, "st_size value: %lld\n", (long long)PL_statcache.st_size);
         mPUSHn(PL_statcache.st_size);
 #else
+        PerlIO_printf(Perl_debug_log, "Using integer for st_size (Off_t_size <= IVSIZE)\n");
+        PerlIO_printf(Perl_debug_log, "st_size value: %lld\n", (long long)PL_statcache.st_size);
         mPUSHi(PL_statcache.st_size);
 #endif
+#endif
+
 #ifdef BIG_TIME
+        PerlIO_printf(Perl_debug_log, "Using floating point for timestamps\n");
         mPUSHn(PL_statcache.st_atime);
         mPUSHn(PL_statcache.st_mtime);
         mPUSHn(PL_statcache.st_ctime);
 #else
+        PerlIO_printf(Perl_debug_log, "Using integer for timestamps\n");
         mPUSHi(PL_statcache.st_atime);
         mPUSHi(PL_statcache.st_mtime);
         mPUSHi(PL_statcache.st_ctime);
 #endif
+
 #ifdef USE_STAT_BLOCKS
+        PerlIO_printf(Perl_debug_log, "Using st_blocks\n");
         mPUSHu(PL_statcache.st_blksize);
         mPUSHu(PL_statcache.st_blocks);
 #else
+        PerlIO_printf(Perl_debug_log, "No st_blocks available\n");
         PUSHs(newSVpvs_flags("", SVs_TEMP));
         PUSHs(newSVpvs_flags("", SVs_TEMP));
 #endif
     }
+    PerlIO_printf(Perl_debug_log, "Completed stat processing\n");
     RETURN;
 }
 
@@ -3524,10 +3621,16 @@ PP(pp_ftis)
         dTARGET;
         switch (op_type) {
         case OP_FTSIZE:
+#ifdef __wasi__
+            /* Force floating point for WASI large files */
+            sv_setnv(TARG, (NV)PL_statcache.st_size);
+#else
+            /* Original size handling logic */
 #if Off_t_size > IVSIZE
             sv_setnv(TARG, (NV)PL_statcache.st_size);
 #else
             sv_setiv(TARG, (IV)PL_statcache.st_size);
+#endif
 #endif
             break;
         case OP_FTMTIME:
@@ -3774,7 +3877,7 @@ PP(pp_fttext)
         const char *file;
         const char *temp;
         STRLEN temp_len;
-        int fd; 
+        int fd;
 
         assert(sv);
         temp = SvPV_nomg_const(sv, temp_len);
@@ -3954,7 +4057,7 @@ PP_wrapped(pp_chdir, MAXARG, 0)
         DIE(aTHX_ PL_no_func, "fchdir");
 #endif
     }
-    else 
+    else
         PUSHs(boolSV( PerlDir_chdir(tmps) >= 0 ));
 #ifdef VMS
     /* Clear the DEFAULT element of ENV so we'll get the new value
